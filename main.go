package main

import "fmt"

// Тема Срезы

//Срезы (slice) представляют последовательность элементов одного типа переменной длины. В отличие от массивов длина
// в срезах не иксирована и динамически может меняться, то есть можно добавлять новые элементы или удалять уже существующие.

func main() {

	// Срез определяется также, как и массив, за тем исключением, что у него не указывается длина:
	// var users = []string{"Tom", "Alice", "Kate"}

	// или так
	// users2 := []string{"Tom", "Alice", "Kate"}

	// К элементам среза обращение происходит также, как и к элементам массива - по индексу и также мы можем перебирать все
	// элементы с помощью цикла for:
	var users []string = []string{"Tom", "Alice", "Kate"}
	fmt.Println(users[2]) // Kate
	users[2] = "Katherine"

	for _, value := range users {
		fmt.Println(value)
	}

	// С помощью функции make() можно создать срез из нескольких элементов, которые будут иметь значения по умолчанию:
	var usersM []string = make([]string, 3)
	usersM[0] = "Tom"
	usersM[1] = "Alice"
	usersM[2] = "Bob"

	// Для добавления в срез применяется встроенная функция append(slice, value). Первый параметр функции - срез, в который
	// надо добавить, а второй параметр - значение, которое нужно добавить. Результатом функции является увеличенный срез.
	usersD := []string{"Tom", "Alice", "Kate"}
	usersD = append(users, "Bob")

	for _, value := range usersD {
		fmt.Println(value)
	}

	/*
		Оператор среза s[i:j] создает из последовательности s новый срез, который содержит элементы последовательности s с i по j-1.
		При этом должно соблюдаться условие 0 <= i <= j <= cap(s). В качестве исходной последовательности, из которой берутся элементы,
		может использоваться массив, указатель на массив или другой срез. В итоге в полученном срезе будет j-i элементов.
		Если значение i не указано, то применяется по умолчанию значение 0. Если значение j не указано, то вместо него используется
		длина исходной последовательности s.
	*/

	// исходный массив
	initialUsers := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
	users1 := initialUsers[2:6] // с 3-го по 6-й
	users2 := initialUsers[:4]  // с 1-го по 4-й
	users3 := initialUsers[3:]  // с 4-го до конца

	fmt.Println(users1) // ["Kate", "Sam", "Tom", "Paul"]
	fmt.Println(users2) // ["Bob", "Alice", "Kate", "Sam"]
	fmt.Println(users3) // ["Sam", "Tom", "Paul", "Mike", "Robert"]

	/*
		Удаление элемента
		Что делать, если необходимо удалить какой-то определенный элемент?
		В этом случае мы можем комбинировать функцию append и оператор среза:
	*/

	usersDelet := []string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}
	// удаляем 4-й элемент
	var n = 3
	usersDelet = append(usersDelet[:n], usersDelet[n+1:]...)
	fmt.Println(usersDelet) //["Bob", "Alice", "Kate", "Tom", "Paul", "Mike", "Robert"]
}
