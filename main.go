package main

import "fmt"

// Тема Отображения

/*
Отображение или map представляет ссылку на хеш-таблицу - структуру данных,
где каждый элемент представляет пару "ключ-значение". При этом каждый элемент имеет уникальный ключ,
по которому можно получить значение элемента. Отображение определяется как объект типа map[K]V,
где К представляет тип ключа, а V - тип значения. Причем тип ключа K должен поддерживать операцию сравнения ==,
чтобы оображение могло сопоставить значение с одним из ключей и хеш-таблицы.
*/

// Например, определение отображения, которое в качестве ключей имеет тип string, а в качестве значений - тип int:
// var people map[string]int Ключи представляют тип string, значения - тип int
func main() {
	// Установка значений отображения:
	var people = map[string]int{
		"Tom":   1,
		"Bob":   2,
		"Sam":   4,
		"Alice": 8,
	}
	fmt.Println(people) // map[Tom:1 Bob:2 Sam:4 Alice:8]

	/*
		Как и в массиве или в срезе элементы помещаютя в фигурные скобки. Каждый элемент представляет пару ключ -значение.
		 Вначале идет ключ и через двоеточие значение. Определение элемента завершается запятой.
	*/
	// Для обращения к элементам нужно применять ключи:
	var peopleK = map[string]int{
		"Tom":   1,
		"Bob":   2,
		"Sam":   4,
		"Alice": 8,
	}
	fmt.Println(peopleK["Alice"]) // 8
	fmt.Println(peopleK["Bob"])   // 2
	peopleK["Bob"] = 32
	fmt.Println(peopleK["Bob"]) // 32

	// Для проверки наличия элемента по определенному ключу можно применять выражение if:
	var peopleF = map[string]int{
		"Tom":   1,
		"Bob":   2,
		"Sam":   4,
		"Alice": 8,
	}
	if val, ok := peopleF["Tom"]; ok {
		fmt.Println(val)
	}

	/*
		Если значение по заданному ключу имеется в отображении, то переменная ok будет равна true, а переменная val
		будет хранить полученное значение. Если переменная ok равна false, то значения по ключу в отображении нет.
	*/

	// Для перебора элементов применяется цикл for:
	var peopleD = map[string]int{
		"Tom":   1,
		"Bob":   2,
		"Sam":   4,
		"Alice": 8,
	}
	for key, value := range peopleD {
		fmt.Println(key, value)
	}

	// Функция make представляет альтернативный вариант создания отображения. Она создает пустую хеш-таблицу:
	// people := make(map[string]int)

	// Добавление и удаление элементов

	/*
		Для добавления элементов достаточно просто выполнить установку значения по
		 новому ключу и элемент с этим ключом будет добавлен в коллекцию:
	*/

	var peopleE = map[string]int{"Tom": 1, "Bob": 2}
	peopleE["Kate"] = 128
	fmt.Println(peopleE) // map[Tom:1  Bob:2  Kate:128]

	/*
		Для удаления применяется встроенная функция delete(map, key), первым параметром которой
		является отображение, а вторым - ключ, по которому надо удалить элемент.
	*/

	var peopleJ = map[string]int{"Tom": 1, "Bob": 2, "Sam": 8}
	delete(peopleJ, "Bob")
	fmt.Println(peopleJ) // map[Tom:1  Sam:8]
}
