package main

import "fmt"

// Указатели

/*
Указатели представляют собой объекты,
значением которых служат адреса других объектов (например, переменных).
*/

/*
Указатель определяется как обычная переменная, только перед типом данных ставится символ звездочки *.
Например, определение указателя на объект типа int:
*/
// var p *int

func main() {

	/*
		Этому указателю можно присвоить адрес переменной типа int.
		Для получения адреса применяется операция &, после которой указывается имя переменной (&x).
	*/

	var x int = 4  // определяем переменную
	var p *int     // определяем указатель
	p = &x         // указатель получает адрес переменной
	fmt.Println(p) // значение самого указателя - адрес переменной x

	/*
		Здесь указатель p хранит адрес переменной x. Что важно, переменная x имеет тип int, и указатель p указывает именно на объект
		типа int. То есть должно быть соответствие по типу. И если мы попробуем вывести адрес переменной на консоль, то увидим, что он
		представляет шестнадцатеричное значение:

		0xc0420120a0

		В каждом отдельном случае адрес может отличаться, но к примеру, в моем случае машинный адрес переменной x - 0xc0420120a0.
		То есть в памяти компьютера есть адрес 0xc0420120a0, по которому располагается переменная x.
		По адресу, который хранит указатель, мы получить значение переменной x. Для этого применяется операция * или операция
		разыменования. Результатом этой операции является значение переменной, на которую указывает указатель. Применим данную
		операцию и получим значение переменной x:
	*/

	var x1 int = 4
	var p1 *int = &x1           // указатель получает адрес переменной
	fmt.Println("Address:", p1) // значение указателя - адрес переменной x
	fmt.Println("Value:", *p1)  // значение переменной x

	// И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:

	var x2 int = 4
	var p2 *int = &x2
	*p2 = 25
	fmt.Println(x2) // 25

	// Для определения указателей можно использовать также сокращенную форму:

	f := 2.3
	pf := &f

	fmt.Println("Address:", pf)
	fmt.Println("Value:", *pf)

	// Пустой указатель
	/*
		Если указателю не присвоен адрес какого-либо объекта, то такой указатель по умолчанию имеет
		значение nil (по сути отстутствие значения). Если мы попробуем получить значение по такому пустому
		указателю, то мы столкнемся с ошибкой:
	*/

	var pf1 *float64
	fmt.Println("Value:", *pf1) // ! ошибка, указатель не указывает на какой-либо объект

	// Поэтому при работе с указателями иногда бывает целесообразано проверять на значение nil:

	var pf2 *float64
	if pf2 != nil {
		fmt.Println("Value:", *pf2)
	}

	// Функция new
	/*
		Переменная представляет именованный объект в памяти. Язык Go также позволяет создавать безымянные объекты - они также
		размещаются в памяти, но не имеют имени как переменные. Для этого применяется функция new(type). В эту функцию передается тип,
		объект которого надо создать. Функция возвращает указатель на созданный объект:
	*/

	p3 := new(int)
	fmt.Println("Value:", *p3) // Value: 0 - значение по умолчанию
	*p3 = 8                    // изменяем значение
	fmt.Println("Value:", *p3) // Value: 8

	/*
		В данном случае указатель p будет иметь тип *int, поскольку он указывает на объект типа int. Создаваемый объект имеет
		значение по умолчанию (для типа int это число 0).
		Объект, созданный с помощью функции new, ничем не отличается от обычной переменной. Единственное что, чтобы обратиться к
		этому объекту - получить или изменить его адрес, необходимо использовать указатель.
	*/
}
