package main

import "fmt"

type person struct {
	name string
	age  int
}

/*
	Метод представляет функцию, связанную с определенным типом. Методы определяются также как и обычные функции за тем исключением,
	что в определении метода также необходимо указать получателя или receiver. Получатель - это параметр того типа, к которому
	прикрепляется метод:
*/

// func (имя_параметра тип_получателя) имя_метода (параметры) (типы_возвращаемых_результатов){тело_метода}

type library []string

/*
	Та часть, которая расположена между ключевым словом func и именем метода и представляет определение получателя, для которого будет
	определен этот метод: (l library). Используя параметр получателя (в данном случае l), мы можем обращаться к получателю. Например,
	в нашем случае получатель представляет срез - набор объектов. С помощью цикла for можно пройтись по этому срезу и вывести все его
	элементы на консоль.

	Поскольку print представляет именно метод, который определен для типа library, а не обычную функцию, то мы можем вызвать этот
	метод у любого объекта типа library:
*/

func (l library) printL() {
	for _, val := range l {
		fmt.Println(val)
	}
}

func (p person) print() {
	fmt.Println("Имя: ", p.name)
	fmt.Println("Возраст: ", p.age)
}

func (p person) eat(meal string) {
	fmt.Println(p.name, "ест", meal)
}

// Методы структур
func main() {
	/*
		lib является объектом типа library, поэтому для него мы можем вызвать метод print. В данном случае объект lib - это и
		будет то значение, которое будет передаваться в функцию print через параметр (l library).
	*/
	var lib library = library{"Book1", "Book2", "Book3"}
	lib.printL()

	var tom = person{name: "TOM", age: 24}
	tom.print()
	tom.eat("борщ с капустой, но не красный")
}

/*
	В данном случае для структуры person определены две функции: print и eat. Функция print выводит информацию о текущем объекте
	person. А функция eat имитирует употребление пищи. Каждая из этих функций определяет объект и тип структуры, к которой функция
	относится:
	func (p person) имя_функции

	С помощью объекта p мы можем обращаться к свойствам структуры person. В остальном это обычные функции, которые могут принимать
	параметры и возвращать результат.
*/

/*
	Для обращения к функциям структуры указывается переменная структуры и через точку идет вызов функциии.
	tom.print()
	tom.eat("борщ")
	В данном случае tom - это и будет объект p person в определении функции.

*/
