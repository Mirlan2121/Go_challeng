Для обработки ошибок, сгенерированных функцией panic, Go предоставляет встроенную функцию recover(). 
Эта функция может служить некоторой аналогией для конструкций try-catch в других языках. Функция recover используется внутри функций defer 
(поскольку после вызова panic выполняются только операторы defer). Функция recover возвращает значение, переданное через panic. Если в программе не было вызовов panic, или recover() 
был вызван не в отложенной функции, то recover() возвращает nil.

Посмотрим на примере с делением на ноль:

package main
import "fmt"
 
func try_catch(){
 
    if r := recover(); r != nil { 
        fmt.Println("Error:", r) 
    }
}
 
func divide(x, y float64) float64{
    defer try_catch()
    if y == 0{ 
        panic("Division by zero!")
    }
    return x / y
}
 
func main() {
    fmt.Println(divide(4, 0))
    fmt.Println("Program has been finished")
}
Эта программа на Go демонстрирует механизм обработки ошибок, похожий на try-catch в других языках программирования, но реализованный с использованием встроенных функций Go: defer, panic и recover.

Прежде всего для перехвата ошибки, которая сгенерирована оператором panic() определена функция try_catch()


func try_catch(){
 
    if r := recover(); r != nil { 
        fmt.Println("Error:", r) 
    }
}
Вначале проверяем был ли вызов panic:

1
if r := recover(); r != nil { ... }
Выражение r := recover() пытается перехватить вызов panic() и присваивает результат функции переменной r.

Далее выражение if r != nil проверяет, был ли вызов panic(). Если r не равно nil, это означает, что был вызов panic() и он успешно перехвачен.

В конце выводим сообщение об ошибке вместе со значением, переданным в panic (в данном случае "Division by zero!"):


fmt.Println("Error:", r)
Далее идет функция divide(), в которой собственно и генерируется ошибка при делении на ноль.


func divide(x, y float64) float64{
    defer try_catch()
    if y == 0{ 
        panic("Division by zero!")
    }
    return x / y
}
Для перехвата ошибки вначале идет вызов defer try_catch(). То есть функция try_catch будет вызвана непосредственно перед тем, как функция divide завершит свое выполнение, 
независимо от того, произошла ли ошибка.

Далее проверяем, равен ли делитель (y) нулю. Если да, то вызывается panic() со строковым сообщением "Division by zero!":


if y == 0 { panic("Division by zero!") }
panic останавливает нормальное выполнение программы и начинает раскручивать стек вызовов, выполняя все отложенные defer-функции.

В функции main() происходит вызов функции divide с аргументами 4 и 0:


fmt.Println(divide(4, 0))
Поскольку y равно 0, функция divide вызовет panic. В итоге этот вызов будет перехвачена функцией try_catch (которая была отложена), и на экран будет выведено сообщение 
"Error: Division by zero!". Консольный вывод:

Возникла ошибка: Division by zero!
0
Program has been finished
Важно отметить, что после перехвата паники с помощью recover() программа продолжит выполнение после точки, где была вызвана функция, содержащая defer и recover. 
В данном случае, это означает, что выполнение продолжится в функции main. Поскольку функция divide вызывает panic() и не возвращает значение (поскольку вызов panic() прерывает нормальный поток выполнения),
fmt.Println не получит возвращаемого значения от divide. И все закончится выполнением строки


fmt.Println("Program has been finished")
Эта строка будет выполнена после того, как вызов panic() будет перехвачен и обработан. Это демонстрирует, что программа не завершилась аварийно, а продолжила выполнение после обработки ошибки.

Если суммировать, то мы получим следующую последовательность действий:

1. Вызывается main(), затем divide(4, 0).

2. Внутри divide, defer try_catch() откладывает выполнение try_catch до выхода из divide.

3. Условие y == 0 истинно, поэтому вызывается panic("Division by zero!").

4. Начинается раскрутка стека. Прежде чем divide полностью завершится, срабатывает отложенная функция try_catch().

5. Внутри try_catch(), recover() перехватывает значение паники ("Division by zero!").

6. fmt.Println("Error:", r) выводит "Error: Division by zero!".

7. Поскольку вызов panic() был перехвачен, программа продолжает выполнение из main().

8. Выводится "Program has been finished".
