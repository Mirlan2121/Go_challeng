Рассмотрим основные моменты. Прежде всего посмотрим на функцию факториала - она возвращает два значения:

func factorial(n int) (int, interface{}){
Первое значение типа int представляет результат, а второе возвращаемое значение теоретически может представлять любой объект, поэтому в качестве его типа указан анонимный интерфейс interface{}, 
который соответствует произвольному объекту. Стоит отметить, что для ошибок в Go есть собственный тип, который можно использовать вместо анонимного интерфейса, но пока посмотрим на общую картину.

В начале функции проверяем значение параметра. И если передано некорректное число - меньше 0, то в качестве результата возвращаем число 0 (недопустимое значение факториала) 
и сообщение об ошибке (интерфейсу interface{} соответствуют все объекты в том числе и строки):

if(n < 0){
    return 0, "Недопустимое число. Должно быть больше 0"
}
Если передано корректное число, то вычисляем факториал числа и в качестве ошибки возвращаем nil:


result := 1
for i := 1; i <= n; i +=1{
    result *= i
}
return result, nil
Далее в функции main два раза вызываем эту функции передевая в нее валидные и невалидные значения. В первом случае передается валидное число 5:


fact, err := factorial(5)
fmt.Println("Factorial:", fact)     // Factorial: 120
fmt.Println("Error:", err)  // Error: <nil>
Во втором случае передается некорректное число -5, поэтому переменная err будет хранить информацию об ошибке:

1
2
3
fact, err := factorial(-5)
fmt.Println("Factorial:", fact)     // Factorial: 0
fmt.Println("Error:", err)  // Error: Недопустимое число. Должно быть больше 0
Проверив переменную err на nil, мы можем узнать, есть ли ошибка или нет.

Это общий механизм, где, конечно, конкретная логика и возвращаемые типы могут отличаться в зависимости от наших потребностей, 
но в общем случае возвращаются два значения, где одно из них представляет информацию об ошибке, а второе - собственно результат функции.
