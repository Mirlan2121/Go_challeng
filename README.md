Оператор defer позволяет выполнить определенную функцию в конце окружающей функции. Обычно с помощью оператора defer выполняется операции очистки, например, 
закрытие файлов, или какие-то действия, которые должны быть выполнены в самом конце.

Оператор defer работает следующим образом:

Оператор defer помещает вызов переданной ему функции в стек. Когда окружающая функция возвращает управление, вызываются все функции, хранящиеся в стеке. Функция, 
хранящаяся в конце стека, выполняется первой. Значения, переданные в аргументах функции defer, вычисляются, когда компилятор находит оператор defer.

В функциях defer могут выполняться как операции чтения, так и записи.

Возвращаемые значения могут быть изменены в функциях defer.

Оператор defer обеспечивает выполнение отложенных функций даже в случае ошибки или вызова функции panic, помогая очищать ресурсы.

Например:


12
package main
import "fmt"
 
func main() {
    defer finish()
    fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}
Здесь функция finish вызывается с оператором defer, поэтому данная функция в реальности будет вызываться в самом конце выполнения программы, несмотря на то, 
что ее вызов определен в начале функции main. В частности, мы получим следующий консольный вывод:

Program has been started
Program is working
Program has been finished
Если несколько функций вызываются с оператором defer, то те функции, которые вызываются раньше, будут выполняться позже всех. Например:


package main
import  "fmt"
 
func main() {
      
    defer finish()
    defer fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}
Консольный вывод:

Program is working
Program has been started
Program has been finished
Более практический пример:


package main 
 
import (
    "fmt"
    "os"
)
 
func open_file(){
 
    // открываем файл
    file, err := os.Open("./main.go") 
    // закрываем файл в конце функции
    defer file.Close()
    // работа с файлом
    fmt.Println("file:", file)
    fmt.Println("error:", err)
}
 
func main(){
 
    open_file()
}
Здесь программа выполняет функцию open_file. Она открывает файл с помощью встроенной функции file.Open(), в которую передается путь к открываемому файлу. 
Но после завершения работы с файлом его надо закрыть. Для этого вызывается другая библиотечная функция - file.Close(). 
Поскольку закрыть файл надо лишь после завершения работы с ним, то предваряем вызов этой функции оператором defer:

1
defer file.Close()
Когда Go начинает выполнение open_file, он видит оператор defer. При анализе этого оператора Go не выполняет вызов file.Close(),
а выполняет последюущие инструкции - выводит информацию о файле и ошибке. И только при завершении функции open_file выполняет вызов file.Close(), закрывая файл.

